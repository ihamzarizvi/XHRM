import { Edition, Selection } from '../interfaces';
import { SelectionStore } from '../store/selection/selection.store';
import Cell = Selection.Cell;
import EditCellStore = Edition.EditCellStore;
declare type StoresMatrix = {
  [y: number]: {
    [x: number]: SelectionStore;
  };
};
declare type StoreByDimension = Record<number, SelectionStore>;
declare type FocusedStore = {
  entity: SelectionStore;
  cell: Selection.Cell;
  position: Selection.Cell;
};
export declare const EMPTY_INDEX = -1;
export default class SelectionStoreConnector {
  private dirty;
  readonly stores: StoresMatrix;
  readonly columnStores: StoreByDimension;
  readonly rowStores: {
    [y: number]: SelectionStore;
  };
  get focusedStore(): FocusedStore | null;
  get edit(): EditCellStore | undefined;
  get focused(): Cell | undefined;
  get selectedRange(): Selection.RangeArea | undefined;
  readonly sections: Element[];
  registerSection(e?: Element): void;
  beforeUpdate(): void;
  registerColumn(x: number): SelectionStore;
  registerRow(y: number): SelectionStore;
  /**
   * Cross store proxy, based on multiple dimensions
   */
  register({ x, y }: Selection.Cell): SelectionStore;
  setEditByCell({ x, y }: Selection.Cell, editCell: Selection.Cell): void;
  beforeNextFocusCell(focus: Selection.Cell): void;
  checkNextStore(focus: Selection.Cell, currentStorePointer: Selection.Cell, lastCell: Selection.Cell): {
    store: SelectionStore;
    item: Partial<Selection.Cell>;
  };
  getCurrentStorePointer(store: SelectionStore): Selection.Cell;
  focusByCell<T extends Cell>(storePos: T, start: T, end: T): void;
  focus(store: SelectionStore, { focus, end }: {
    focus: Cell;
    end: Cell;
  }): void;
  clearAll(): void;
  setEdit(val: string | boolean): void;
  getXStores(y: number): {
    [x: number]: SelectionStore;
  };
  getYStores(x: number): {
    [p: number]: SelectionStore;
  };
}
export {};
